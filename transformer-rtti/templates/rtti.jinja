#include "transformer-rtti/stdlib/Array.h"
#include "transformer-rtti/RecordTypeInfo.h"
#include "transformer-rtti/ArrayTypeInfo.h"
#include "transformer-rtti/EnumTypeInfo.h"

#include "{{ main_file_path }}"
## for include in valueOr(included_files, [])
## if include.was_in_quotes
#include "{{ include.file_path }}"
## else
#include <{{ include.file_path }}>
## endif
## endfor

using namespace transformer::rtti;
## for ns in default(using_namespaces, [])
namespace {{ ns }} {} // TODO(FiTH): remove this HACK! implement own TypePrinter
using namespace {{ ns }};
## endfor

namespace
{

// TODO(FiTH): make namespace with name "c.full_name" or "class_0" and remove "loop.index" from names of fields?
## for c in valueOr(classes, [])
## if not c.is_templated
//
//	{{ c.full_name }}
//

## if length(c.base_classes)
const RecordBaseInfo class_{{ loop.index }}_bases[] = {
## for base_class_name, b in c.base_classes
	{
## if default(b.is_std_internal_type, false)
		.id     = {}, // TODO(FiTH): std internal type
## else
		.id     = DB::get_type_id<{{ b.name }}>(),
## endif
		.offset = {{ b.offset_in_chars }}
	},
## endfor
};

## endif
## if length(c.fields)
const RecordFieldInfo class_{{ loop.index }}_fields[] = {
## for f in c.fields
	{
		.name      = "{{ f.name }}",
		.offset    = {{ f.offset_in_chars }},
## if f.is_anonymous_struct_or_union
		.qual_type = {} // TODO(FiTH): anonymous struct or union
## else if f.type.access == "private"
		.qual_type = {} // TODO(FiTH): private or protected field. Check if we are 'friends'
## else if default(f.type.is_std_internal_type, false)
		.qual_type = {} // TODO(FiTH): std internal type
## else
		.qual_type = QualifiedType::get_qualified_type<{{ f.type.name }}>()
## endif
	},
## endfor
};

## endif
## if length(c.methods)
// TODO(FiTH): if m.access == "public" OR 'friend class DB;'
## for m in c.methods
## if length(m.parameters)
const RecordMethodParamInfo class_{{ loop.parent.index }}_method_{{ loop.index }}_params[] = {
## for p in m.parameters
	{
		.name = "{{ p.name }}",
		.type = QualifiedType::get_qualified_type<{{ p.type.canonical_name }}>()
	},
## endfor
};

## endif
## endfor
## for m in c.methods
// TODO(FiTH): uncomment this after gcc update to full support of 'requires'
// template<typename T>
// concept is_valid_class_{{ loop.parent.index }}_method_{{ loop.index }} = requires (T self{% for p in valueOr(m.parameters, []) %}, {{ p.type.canonical_name }} arg_{{ loop.index }}{% endfor %}) { // {{ c.full_name }}::{{ m.name }}
// 	self->{{ m.name }}(
## for p in valueOr(m.parameters, [])
// 		arg_{{ loop.index }}{% if not loop.is_last %},{% endif %}
//
## endfor
// 	);
// };
//
## endfor
## for m in c.methods
## if m.access == "public"
template<typename T>
struct is_valid_class_{{ loop.parent.index }}_method_{{ loop.index }}
{
	using  one = char;
	struct two { char data[2]; };

	using return_type = {{ m.return_type.canonical_name }};

	template<typename C> static one test(decltype(static_cast<return_type (C::*)({% for p in valueOr(m.parameters, []) %}{{ p.type.canonical_name }}{% if not loop.is_last %}, {% endif %}{% endfor %})>(&C::{{ m.name }})));
	template<typename C> static two test(...);

	static constexpr bool value = (sizeof(test<T>(nullptr)) == sizeof(one));
};

## endif
## endfor
const RecordMethodInfo class_{{ loop.index }}_methods[] = {
## for m in c.methods
## if m.access == "public"
	{
		// TODO(FiTH): make 2 versions of methods that take argument 'by value' - with copy constructor and move constructor
		.name     = "{{ m.name }}", // {{ m.access }}: {{ m.return_type.name }} {{ c.name }}::{{ m.name }}({% for p in valueOr(m.parameters, []) %}{{ p.type.name }} {{ p.name }}{% if not loop.is_last %}, {% endif %}{% endfor %})
		.ptr      = [](const void* self, void*{% if m.return_type.canonical_name != "void" %} ret {% endif %}, const void*{% if length(m.parameters) %} args{% endif %}[]) noexcept
			{
				[&](auto* self_ptr)
				{
					if constexpr (is_valid_class_{{ loop.parent.index }}_method_{{ loop.index }}<decltype(self_ptr)>::value) {
				// TODO(FiTH): WARNING! VERY IMPORTANT! Re-check logic of passing arguments and returning value for UNNECESSARY COPIES!
				// TODO(FiTH): add debug version? if we are doing 'move' - arg should be able to do this
				// TODO(FiTH): this lambda must be a macro in inja!
				const auto call = [&]() noexcept -> {{ m.return_type.canonical_name }} {
					{% if m.return_type.canonical_name != "void" %}auto&& ret = {% endif %}self_ptr->{{ m.name }}(
## for p in valueOr(m.parameters, [])
						{% if p.type.is_rvalue_reference %}
							std::move(*static_cast<std::remove_reference_t<{{ p.type.canonical_name }}>*>(const_cast<void*>(args[{{ loop.index }}])))
						{% else %}
							[](auto& arg) -> decltype(auto) {
								if constexpr (std::is_copy_constructible_v<decltype(arg)>) return arg;
								else return std::move(arg);
							}(*static_cast<std::remove_reference_t<{{ p.type.canonical_name }}>*>(const_cast<void*>(args[{{ loop.index }}])))
						{% endif %}{% if not loop.is_last %},{% endif %}

## endfor
					);

## if m.return_type.canonical_name != "void"
## if m.return_type.is_reference
					return ret;
## else
					if constexpr (std::is_copy_constructible_v<{{ m.return_type.canonical_name }}>)
						return ret;
					else
						return std::move(ret);
## endif
## endif
				};

## if m.return_type.canonical_name != "void"
				if (ret != nullptr) {
## if m.return_type.is_lvalue_reference
					using return_type = {{ m.return_type.pointee_type.canonical_name }};
					new (ret) return_type* { &call() };
## else
					using return_type = {{ m.return_type.canonical_name }};
					new (ret) return_type { call() };
## endif
				} else {
					call();
				}
## else
				call();
## endif
					} else {
						// TODO(FiTH): assert(false)
					}
				}({% if m.is_const %}static_cast<const {{ c.full_name }}*>(self){% else %}static_cast<{{ c.full_name }}*>(const_cast<void*>(self)){% endif %});
			},
		.is_const = {{ m.is_const }},
		.ret_type = QualifiedType::get_qualified_type<{{ m.return_type.canonical_name }}>(),
		.params   = {% if length(m.parameters) %}class_{{ loop.parent.index }}_method_{{ loop.index }}_params{% else %}{}{% endif %}

	},
## endif
## endfor
};

## endif
## if default(c.is_template_specialization, false)
const TypeID class_{{ loop.index }}_template_args[] = {
## if length(c.template.args)
## for arg in c.template.args
	DB::get_type_id<{{ arg.name }}>(),
## endfor
## else
// TODO(FiTH): not template args? all default? is this a problem?
## endif
};

const RecordTemplateSpecializationTypeInfo class_{{ loop.index }} = {
	/* RecordTypeInfo */ {
		/* NamedTypeInfo */ {
			/* TypeInfo */ {
				.id   = DB::set_type_info(&class_{{ loop.index }}, DB::get_type_id<{{ c.full_name }}>()),
				.kind = TypeKind::RECORD_TEMPLATE_SPECIALIZATION_TYPE
			},
			/* .name = */ "{{ c.name }}"
			// TODO(FiTH): /* .full_name = */ "{{ c.full_name }}"
		},
		/* .bases      = */ {% if length(c.base_classes) %}class_{{ loop.index }}_bases{% else %}{}{% endif %},
		/* .bases_map  = */ {
## for base_class_name, b in valueOr(c.base_classes, {})
			{ class_{{ loop.parent.index }}_bases[{{ loop.index }}].id, &class_{{ loop.parent.index }}_bases[{{ loop.index }}] },
## endfor
		},
		/* .fields     = */ {% if length(c.fields) %}class_{{ loop.index }}_fields{% endif %},
		/* .fields_map = */ { // TODO(FiTH): do same check for 'bases_map'?
## for f in valueOr(c.fields, [])
## if f.is_anonymous_struct_or_union
			// TODO(FiTH): anonymous struct or union
## else if f.type.access == "private"
			// TODO(FiTH): private or protected field. Check if we are 'friends'
## else if default(f.type.is_std_internal_type, false)
			// TODO(FiTH): std internal type
## else
			{ "{{ f.name }}", &class_{{ loop.parent.index }}_fields[{{ loop.index }}] },
## endif
## endfor
		},
		/* .methods     = */ { {% if length(c.methods) %}class_{{ loop.index }}_methods{% else %}{}{% endif %} },
		/* .methods_map = */ { // TODO(FiTH): handle overloaded and templated methods
## set method_index = 0
## for m in valueOr(c.methods, [])
## if m.access == "public"
			{ "{{ m.name }}", &class_{{ loop.parent.index }}_methods[{{ method_index }}] },
## set method_index = method_index + 1
## endif
## endfor
		}
	},
	/* template_type_id = */ DB::get_type_id<{{ c.template.full_name }}>(),
	/* template_args    = */ class_{{ loop.index }}_template_args
};
## else
const RecordTypeInfo class_{{ loop.index }} = { // is record template: {{ default(c.is_record_template, false) }}
	/* NamedTypeInfo */ {
		/* TypeInfo */ {
			.id   = DB::set_type_info<{{ c.full_name }}>(&class_{{ loop.index }}),
			.kind = TypeKind::RECORD_TYPE
		},
		/* .name = */ "{{ c.name }}"
		// TODO(FiTH): /* .full_name = */ "{{ c.full_name }}"
	},
	/* .bases      = */ {% if length(c.base_classes) %}class_{{ loop.index }}_bases{% else %}{}{% endif %},
	/* .bases_map  = */ {
## for base_class_name, b in valueOr(c.base_classes, {})
		{ class_{{ loop.parent.index }}_bases[{{ loop.index }}].id, &class_{{ loop.parent.index }}_bases[{{ loop.index }}] },
## endfor
	},
	/* .fields     = */ {% if length(c.fields) %}class_{{ loop.index }}_fields{% else %}{}{% endif %},
	/* .fields_map = */ { // TODO(FiTH): do same check for 'bases_map'?
## for f in valueOr(c.fields, [])
## if f.is_anonymous_struct_or_union
			// TODO(FiTH): anonymous struct or union
## else if f.type.access == "private"
			// TODO(FiTH): private or protected field. Check if we are 'friends'
## else if default(f.type.is_std_internal_type, false)
			// TODO(FiTH): std internal type
## else
		{ "{{ f.name }}", &class_{{ loop.parent.index }}_fields[{{ loop.index }}] },
## endif
## endfor
	},
	/* .methods     = */ { {% if length(c.methods) %}class_{{ loop.index }}_methods{% endif %} },
	/* .methods_map = */ { // TODO(FiTH): handle overloaded and templated methods
## set method_index = 0
## for m in valueOr(c.methods, [])
## if m.access == "public"
		{ "{{ m.name }}", &class_{{ loop.parent.index }}_methods[{{ method_index }}] },
## set method_index = method_index + 1
## endif
## endfor
		}
};
## endif

## endif
## endfor
// TODO(FiTH): inja does not support 'short-circuit evaluation'!
## for canonical_unqualified_type_name, t in used_types
## if default(t.is_record_template, false)
const RecordTemplateTypeInfo used_type_{{ loop.index }} = {
	/* NamedTypeInfo */ {
		/* TypeInfo */ {
			.id   = DB::set_type_info(&used_type_{{ loop.index }}, DB::get_type_id<{{ t.full_name }}>()),
			.kind = TypeKind::RECORD_TEMPLATE_TYPE
		},
		/* .name = */ "{{ t.name }}"
		// TODO(FiTH): /* .full_name = */ "{{ t.full_name }}"
	}
};
## else if t.is_pointer or (t.is_reference and default(t.pointee_type.is_pointer, false))
const PointerTypeInfo used_type_{{ loop.index }} = {
	/* TypeInfo */ {
		.id   = DB::set_type_info<{{ canonical_unqualified_type_name  }}>(&used_type_{{ loop.index }}), // TODO(FiTH): {{ t.name }}
		.kind = TypeKind::POINTER_TYPE
	},
	/* .pointee_type = */ QualifiedType::get_qualified_type<{{ t.pointee_type.name }}>()
};
## else if t.is_array or (t.is_reference and default(t.pointee_type.is_array, false))
const ArrayTypeInfo used_type_{{ loop.index }} = {
	/* PointerTypeInfo */ {
		/* TypeInfo */ {
			.id   = DB::set_type_info<{{ t.name }}>(&used_type_{{ loop.index }}),
			.kind = TypeKind::ARRAY_TYPE
		},
		/* .pointee_type = */ QualifiedType::get_qualified_type<{{ t.pointee_type.name }}>()
	},
	/* .extent = */ {{ t.array_size }}
};
## else if t.is_record
// TODO(FiTH): this is record, it must be reported in file where it was defined: {{ canonical_unqualified_type_name }}.
//             So remove this comment?
## else if t.access != "private"
// static_assert(false, "TODO(FiTH): Warning! Unsupported type: {{ canonical_unqualified_type_name }}");
#warning "TODO(FiTH): Warning! Unsupported type: {{ canonical_unqualified_type_name }}"

/*
	{{ t }}
*/
## else
// TODO(FiTH): private or protected type. Check if we are 'friends' - {{ canonical_unqualified_type_name }}
## endif

## endfor
// TODO(FiTH): "static_cast<e.integer_type>(-...ull)" and "{group_value}ull" - is this UB?))) I hope not...

## for e in valueOr(enums, [])
//
//	{{ e.full_name }}
//

## if length(e.enumerators)
const EnumConstantInfo enum_{{ loop.index }}_enumerators[] = {
## for enumerator in e.enumerators
	{
		.name = "{{ enumerator.name }}",
		.{% if e.integer_type.is_unsigned_integer %}un{% endif %}signed_value = static_cast<{{ e.integer_type.name }}>({{ enumerator.value }}ull)
	},
## endfor
};

## for enumerator in e.enumerators
constexpr uint32_t enum_{{ loop.parent.index }}_{{ enumerator.name }}_index = {{ loop.index }};
## endfor

## endif
## for group_value, enumerators in valueOr(e.enumerators_grouped_by_value, {})
const EnumConstantInfo* const enum_{{ loop.parent.index }}_{{ enumerators.0.name }}_group[] = {
## for en in enumerators
	&enum_{{ loop.parent.parent.index }}_enumerators[enum_{{ loop.parent.parent.index }}_{{ en.name }}_index],
## endfor
};

## endfor
const EnumTypeInfo enum_{{ loop.index }} = {
	/* NamedTypeInfo */ {
		/* TypeInfo */ {
			.id   = DB::set_type_info<{{ e.full_name }}>(&enum_{{ loop.index }}),
			.kind = TypeKind::ENUM_TYPE
		},
		/* .name = */ "{{ e.name }}"
	},
	/* .integer_type          = */ DB::get_type_id<{{ e.integer_type.name }}>(),
	/* .enumerators           = */ {% if length(e.enumerators) %}enum_{{ loop.index }}_enumerators{% else %}{}{% endif %},
	/* .enumerators_map       = */ {
## for enumerator in valueOr(e.enumerators, [])
		{ "{{ enumerator.name }}", &enum_{{ loop.parent.index }}_enumerators[{{ loop.index }}] },
## endfor
	},
	/* .enumerators_value_map = */ {
## for group_value, enumerators in valueOr(e.enumerators_grouped_by_value, {})
		{ {{ group_value }}ull, enum_{{ loop.parent.index }}_{{ enumerators.0.name }}_group },
## endfor
	}
};

## endfor
}
